package source;

import org.apache.log4j.*;
import java_cup.runtime.*;
import util.ParserHelper;

parser code {:
	Logger log = Logger.getLogger(getClass());
	ParserHelper parserHelper = new ParserHelper();

	public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
	}
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROGRAM, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, FOR, EXTENDS, CONTINUE, STATIC;
terminal IDENT;
terminal NUMCONST, CHARCONST, BOOLCONST;
terminal PLUS, MINUS, MUL, DIV, MOD, EQU, NOTEQU, GT, GTEQU, LE, LEQU, AND, OR, ASSIGN, PLUSASSIGN, MINUSASSIGN, MULASSIGN, DIVASSIGN, MODASSIGN, INCREMENT, DECREMENT, SEMICOLON, COMMA, DOT, LPAREN, RPAREN, LINDEX, RINDEX, LCURLYBRACE, RCURLYBRACE;

non terminal Program, ProgramDeclarationListOpt, ProgramBody, ConcreteProgramDeclarations;
non terminal ConstantDeclarationWrapper, ClassDeclaration, VariableDeclarationWrapper;
non terminal Type;
non terminal ConstantDeclarationList, ConstantDeclaration, Constant;
non terminal ExtendsOpt, ClassBody;
non terminal MethodDeclarationListOpt, MethodDeclaration, StaticOpt, MethodReturnType, FormalParamListOpt, 
		FormalParamList, FormalParam;
non terminal StatementListOpt, StatementList;
non terminal VariableDeclarationWrapperListOpt, VariableDeclarationList, VariableDeclaration;
non terminal Statement, DesignatorStatement, IfStatement, ForStatement, ReturnStatement, ReadStatement, PrintStatement;
non terminal Designator, DesignatorOperation, AssignOperator;
non terminal AddOpRight, MulOpRight, AddOpLeft, MulOpLeft; 
non terminal ActualParamListOpt, ActualParamList, ExpressionList;
non terminal Expression, MinusOpt;
non terminal TermList, Term, AddOp, FactorList, Factor, MulOp;
non terminal FunctionCall, ConstructorCall;
non terminal ObjectPropertyRef, ArrayElemRef, IndexingList;
non terminal Condition, ElseOpt, ConditionTermList, ConditionTerm, ConditionFactorList, ConditionFactor, Relop;
non terminal DesignatorStatementOpt, ConditionOpt, ExpressionOpt, NumConstOpt, IndexingExpressionOpt;

precedence left ELSE;

Program ::= PROGRAM IDENT:ProgramName ProgramDeclarationListOpt LCURLYBRACE {: parser.parserHelper.enteringProgram(); :} ProgramBody {: parser.parserHelper.exitingProgram(); :} RCURLYBRACE;
ProgramDeclarationListOpt ::=  ProgramDeclarationListOpt ConcreteProgramDeclarations | /* epsilon */;
ConcreteProgramDeclarations ::= ConstantDeclarationWrapper | ClassDeclaration | VariableDeclarationWrapper;
ProgramBody ::= MethodDeclarationListOpt;

ConstantDeclarationWrapper ::= CONST Type ConstantDeclarationList SEMICOLON;
ConstantDeclarationList ::= ConstantDeclaration | ConstantDeclaration COMMA ConstantDeclarationList;
ConstantDeclaration ::= IDENT:ConstName ASSIGN Constant:Const
						{:
							if(!parser.parserHelper.isInProgram())
								parser.parserHelper.globalConstFound();
						:};
Constant ::= NUMCONST | CHARCONST | BOOLCONST;

ClassDeclaration ::= CLASS IDENT:ClassName ExtendsOpt LCURLYBRACE VariableDeclarationWrapper ClassBody RCURLYBRACE;
ExtendsOpt ::= EXTENDS Type | /* epsilon */;
ClassBody ::= MethodDeclarationListOpt;

MethodDeclarationListOpt ::= MethodDeclarationListOpt MethodDeclaration | /* epsilon */;
MethodDeclaration ::= StaticOpt MethodReturnType IDENT:MethodName 
					{: 
						if(MethodName.equals("main"))
							parser.parserHelper.enteringMain();
					:} 
					LPAREN FormalParamListOpt RPAREN VariableDeclarationWrapperListOpt
					{: parser.parserHelper.exitingMain(); :}
					LCURLYBRACE StatementListOpt RCURLYBRACE;
StaticOpt ::= STATIC | /* epsilon */;
MethodReturnType ::= VOID | Type;
FormalParamListOpt ::= FormalParamList | /* epsilon */;
FormalParamList ::= FormalParamList COMMA FormalParam | FormalParam;
FormalParam ::= Type IDENT:ParamName | Type IDENT:ParamName LINDEX RINDEX;

VariableDeclarationWrapperListOpt ::= VariableDeclarationWrapperListOpt VariableDeclarationWrapper | /* epsilon */;
VariableDeclarationWrapper ::= Type VariableDeclarationList SEMICOLON;
VariableDeclarationList ::= VariableDeclarationList COMMA VariableDeclaration | VariableDeclaration;
VariableDeclaration ::= IDENT:VarName 
						{:
							if(!parser.parserHelper.isInProgram())
								parser.parserHelper.globalVarFound();
							else if(parser.parserHelper.isInMain())
								parser.parserHelper.localVarFound();
						:}
						| IDENT:VarName LINDEX RINDEX
						{:
							if(!parser.parserHelper.isInProgram())
								parser.parserHelper.globalArrayFound();
						:};

Type ::= IDENT:TypeName;

Statement ::= DesignatorStatement SEMICOLON
				| IfStatement
				| ForStatement
				| BREAK SEMICOLON
				| CONTINUE SEMICOLON
				| ReturnStatement SEMICOLON
				| ReadStatement SEMICOLON
				| PrintStatement SEMICOLON
				| LCURLYBRACE StatementListOpt RCURLYBRACE;

StatementListOpt ::= StatementList | /* epsilon */;
StatementList ::= StatementList Statement | Statement;

DesignatorStatementOpt ::= DesignatorStatement | /* epsilon */;
DesignatorStatement ::= Designator DesignatorOperation;
DesignatorOperation ::= AssignOperator Expression | LPAREN ActualParamListOpt RPAREN | INCREMENT | DECREMENT;
AssignOperator ::= ASSIGN | AddOpRight | MulOpRight;
AddOpRight ::= PLUSASSIGN | MINUSASSIGN;
MulOpRight ::= MULASSIGN | DIVASSIGN | MODASSIGN;
ActualParamListOpt ::= ActualParamList | /* epsilon */;
ActualParamList ::= ExpressionList;
ExpressionList ::= ExpressionList COMMA Expression | Expression;

ExpressionOpt ::= Expression | /* epsilon */;
Expression ::= MinusOpt TermList;
MinusOpt ::= MINUS | /* epsilon */;
TermList ::= TermList AddOp Term | Term;
Term ::= FactorList;
FactorList ::= FactorList MulOp Factor | Factor;
Factor ::= Designator
			| FunctionCall
			| NUMCONST
			| CHARCONST
			| BOOLCONST
			| ConstructorCall
			| LPAREN Expression RPAREN;

AddOp ::= AddOpLeft | AddOpRight;
AddOpLeft ::= PLUS | MINUS;
MulOp ::= MulOpLeft | MulOpRight;
MulOpLeft ::= MUL | DIV | MOD;



Designator ::= IDENT:VarName | ObjectPropertyRef | ArrayElemRef;
ObjectPropertyRef ::= Designator DOT IDENT:propertyName;
ArrayElemRef ::= Designator IndexingList;
IndexingList ::= LINDEX Expression:IndexingExpression RINDEX;

IfStatement ::= IF LPAREN Condition RPAREN Statement ElseOpt;
ElseOpt ::= ELSE Statement | /* epsilon */;

ConditionOpt ::= Condition | /* epsilon */;
Condition ::= ConditionTermList;
ConditionTermList ::= ConditionTermList OR ConditionTerm | ConditionTerm;
ConditionTerm ::= ConditionFactorList;
ConditionFactorList ::= ConditionFactorList AND ConditionFactor | ConditionFactor;
ConditionFactor ::= Expression | Expression Relop Expression;
Relop ::= EQU | NOTEQU | GT | GTEQU | LE | LEQU;

ForStatement ::= FOR LPAREN DesignatorStatementOpt SEMICOLON ConditionOpt SEMICOLON DesignatorStatementOpt RPAREN Statement;

ReturnStatement ::= RETURN ExpressionOpt;

ReadStatement ::= READ LPAREN Designator RPAREN;

PrintStatement ::= PRINT LPAREN Expression NumConstOpt RPAREN;
NumConstOpt ::= COMMA NUMCONST | /* epsilon */;

FunctionCall ::= Designator:FunctionName LPAREN ActualParamListOpt RPAREN;
ConstructorCall ::= NEW Type:ClassName IndexingExpressionOpt;
IndexingExpressionOpt ::= LINDEX Expression RINDEX;


























		